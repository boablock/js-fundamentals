<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Fundamentos JavaScript</h1>
    <P>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Neque ut tempora explicabo ab aliquam ipsam possimus veniam quae in. Error quidem minus quos neque deleniti obcaecati eius consequatur possimus culpa.</P>
    <ul>
        <li> Primavera</li>
        <li> Verano </li>
        <li> Oto√±o </li>
        <li> Invierno </li>
    </ul>
    <script>
        // var hola = 'Hola mundo';
        // let hello = 'Hello world'
        // console.log(hola);
        // console.log(hello);
        // console.log(window);
        // console.log(window.hola);
        // console.log(window.hello);
        // // Ambito de bloque 
        // var musica = 'rock';
        // console.log('Variable musica antes del bloque ', musica);
        // {
        //     let  musica = 'pop';
        //     console.log('Variable musica dentro del bloque', musica );
        // }
        // console.log('Variable musica despues del bloque', musica );
    // CONSTANTES 
    /*
    - No puedes declarar una constante vacia
    - No debe cambiar el valor durante el flujo del programa (simpre que sean valores primitivos, ya que se accede directamente al valor). Con valores compuestos (arrays, objects), se accede a una referencia del valor, se puede usar ya que la referencia no combio, sigue siendo un objeto o un arreglo. 
    */
   /*
        const PI =3.1416
        console.log(PI);

        const objeto = {
            nombre: "jon",
            edad: 35
        }
        const colores = ['amarillo','azul', 'rojo']

        console.log(objeto);
        console.log(colores);

        objeto.correo = 'jonmircha@msn.com'
        colores.push ('aranjado')

        console.log(objeto);
        console.log(colores);
    */
    /* 
        //Cadenas de texto aka Strings
        let nombre='Jon' 
        let apellido = "Mircha"
        let saludo = new String("Hola mundo")
        let lorem = '        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Neque ut tempora explicabo ab aliquam ipsam possimus veniam quae in. Error quidem minus quos neque deleniti obcaecati eius consequatur possimus culpa           '

        console.log(nombre,apellido,saludo);
        console.log(
        nombre.length,
        apellido.length,
        saludo.length,
        nombre.toLowerCase(),
        apellido.toUpperCase(),
        lorem.includes('amet'),
        lorem.includes('jon'),
        lorem, 
        lorem.trim(),
        lorem.split(" "),
        lorem.split(",")
        );
    */
/*
    // Concatenacion
    let nombre = 'jon';
    let apellido = 'Mircha';

    let saludo = 'Hola mi nombre es ' + nombre + ' ' + apellido + '.'
    console.log(saludo);

    // Interpolacion de variables 
    // Templetes Strings¬¥
    let saludo2 = `Hola mi nombre es ${nombre} ${apellido} .`
    console.log(saludo2);

    let ul = ` 
    <ul>
        <li> Primavera</li>
        <li> Verano </li>
        <li> Oto√±o </li>
        <li> Invierno </li>
    </ul>`
    console.log(ul);
    
    // Numbers
    let a = 2;
    let b = new Number (1);
    let c = 7.19;
    let d = '5.6'
    console.log(a,b);
    console.log(c.toFixed(1));
    console.log(c.toFixed(5));
    console.log(parseInt(c));
    console.log(parseFloat(c));
    console.log(typeof c, typeof d);
    console.log(a + b);
    console.log(c + d); // transforma el number en string y no lo suma
    console.log(c + parseInt(d)); // 12.19
    console.log(c + parseFloat(d));
    // TODOS ESTOS METODOS CUELGAN DEL OBJETO Number; son metodos directos del CONSTRUCTOR Number:
    console.log(c + Number.parseFloat(d));
    console.log(c + Number.parseInt(d));
*/
/*
    // Booleans
    let verdadero = true;
    let falso = false; 
    let v = Boolean(true)
    let f = Boolean (false)
    console.log(verdadero, falso, v, f );
    console.log(typeof verdadero, typeof falso)
    // falsy and truthy
    console.log(Boolean(0));
    console.log(Boolean(1));
    console.log(Boolean(""));
    console.log(Boolean(" "));
    console.log(Boolean({}));
    console.log(Boolean([]));
    console.log(Boolean(NaN));
    console.log(Boolean(null));

*/
/*
    // Undefined, null, Nan
    //Undefined: Variable que no fue inicializada.
    let indefinida; 
    let nulo = null; //Asignado intencionalmente por el programador
    console.log(indefinida); //undefined, lo tira js, no se le asifno valor
    console.log(nulo); // es asignado por el programador, es un valor asignado.

    //NaN - Not a Number
    let noEsUnNumero = 'Hola' * 3.5;
    console.log(noEsUnNumero); //NaN 
*/

    // // Funcion declarada
    // function estoEsUnaFuncion(){
    //     console.log('uno');
    //     console.log('dos'); 
    //     console.log('tres');
    // }

    // function unaFuncionQueDevuelveValores(){
    //     console.log('uno');
    //     return '19' //-> corta la ejecucion de la funcion 
    //     console.log('dos'); 
    //     console.log('tres');
    //     return 'La funcion retorna una cadena de texto '
    // }
    // //Invocacion
    // // estoEsUnaFuncion();
    // // let valorDeFuncion = unaFuncionQueDevuelveValores();
    // // console.log(valorDeFuncion);

    // function saludar(nombre = 'desconocido', edad = 6 ){
    //     console.log(`Hola mi nombre es ${nombre} y tengo ${edad} a√±os`);
    // }

    // saludar('Akiba', 7);
    // saludar();
    // // Funciones declaradas VS funciones expresadas 
    // funcionDeclarada(); //--> hoisting, lo imprime igual 
    // function funcionDeclarada(){
    //     console.log('Esto es un funcion declarada y puede invocarse en cualquier parte de nuestro codigo, incluso antes de que la funcion sea declarada');
    // }

    // funcionDeclarada();

    // funcionExpresada();
    // // Funcion anonima 
    // const funcionExpresada = function (){
    //     console.log('Esto es una funcion expresada, es decir, una funcion que se le ha asignado como valor a una variable, si invocamos esta funcion antes de su definicion, JS nos dira..Cannot access funcionExpresada before initialization');
    // }
    // funcionExpresada();
/*
    //Arreglos
    const a = []
    const b = [1, true, 'Hola', ['a', 'b', 'c',[1,2,'üêä']]]
    console.log(a);
    console.log(b);
    console.log(b.length); // 4
    console.log(b[2]); // Hola
    console.log(b[3][3][2]);

    const c = Array.of('x','y','z', 1,2)
    console.log(c);

    const d = Array(100).fill(false);
    console.log(d);

    const e = new Array();
    console.log(e);

    const f = new Array (1,2,3)
    console.log(f);

    const colores = ['Azul', 'Rojo', 'Verde']
    console.log(colores);

    colores.push('Anaranjado')
    console.log(colores);

    colores.pop();
    console.log(colores);
    
    colores.forEach(function(el,index){
        console.log(`<li id='${index}'>${el}</li>`);
    })
*/
    // Objects
    // variables de los objetos --> atributos
    // funciones de los objetos --> metodos
/*
    let a = new String('Hola')
    // console.log(a);

    const b = {}

    console.log(b);

    const c = new Object();
    console.log(c);

    const jon = {
        name: 'juampi',
        surname: 'Boada',
        age: '29',
        pasatiempos:['clases de tenis','programar'],
        contacto: {
            email:'Juampi_boada@gmail.com',
            twitter:'Juampi.boa'
        },
        saludar: function (){
            console.log('Hello =)');
        },
        decirMiNombre: function(){
            console.log(`hola me llamo ${this.name} y tengo ${jon.age}`);
        }
    }

    console.log(jon);
    console.log(jon['name']); // juampi
    console.log(jon.name); // Juampi
    console.log(jon['surname']); // Boada
    console.log(jon.surname); // Boada
    console.log(jon.pasatiempos);
    console.log(jon.pasatiempos[0]);
    console.log(jon.contacto);
    console.log(jon.contacto.twitter);
    console.log(jon.saludar);
    jon.decirMiNombre();

    console.log(Object.keys(jon));
    console.log(Object.values(jon));
    console.log(jon.hasOwnProperty('name')); // true  
    console.log(jon.hasOwnProperty('nombre')); // false
*/
/*
    // 16) BUGS HANDLE STRUCTURE - FINALLY
        try{
            console.log('On try we add code to evaluate it ');
            noExist;
            console.log('Second try mensage');
        }catch(error){
            console.log('Catch capture try codes bugs');
            console.log(error);
        }finally{
            console.log('Finally will be executed at the end of the try-catch block');
        }

        try{
            let numero ='y';
            if(isNaN(numero)){
                throw new Error('The input character is not a number')
            }

            console.log(numero * numero);
        }catch(error){
            console.log(`the following error occurred ${error}`);
        }
    */
        // 17) BREAK AND CONTINUE --> for control structure for, while, do while, switch
    /*
            const numeros = [1,2,3,4,5,6,7,8,9,0];
            
            for (let i = 0; i < numeros.length; i++){
                if(i === 5){
                    break; // break in the fifth iteration
                }
                console.log(numeros[i]);
            }
            for (let i = 0; i < numeros.length; i++){
                if(i === 5){
                    continue; // the sixth iteration is skipped
                }
                console.log(numeros[i]);
            }
    */
            // 18) DESTRUCTURING
    /*
                let numeros = [1,2,3]

                let uno = numeros[0]
                 dos = numeros[1]
                 tres = numeros[2]

                console.log(uno, dos, tres); // 1,2,3

            // WITH DESTRUCTURING
                const [one, two, three] = numeros; // to each of array positions, im keeping in the variables one,two, three
                console.log(one, two, three); // 1,2,3

                const person = {
                    name: 'Pepe',
                    surname: ' Loco',
                    age: 22
                }

                const {name, surname, age} = person

                console.log(name, surname, age); //--> en la destructuracion de los obejtos se deben respetar los nombres de los attributos o variables
                //--> in object destructuring name atributes must be respected

    */
                //19) Literal Objects --> new way to write and asign attributes and methods. Literal objects makes writing procces more easy, facilitates objects writing process. When the value of the atribute and the name are the same. 
    /*
                let name = 'Kenai';
                let  age = 7;

                const dog = {
                    name: name,
                    age: age,
                    ladrar: function(){
                        console.log('GUAU GUAUUU');
                    }
                }

                console.log(dog);
                dog.ladrar();

                const perro = {
                    name,
                    age,
                    breed: 'labrador',
                    ladrar(){
                        console.log('GUAU GUAUUUU GUAUUU');
                    }
                }

                console.log(perro);
                perro.ladrar();

        */
                //20) REST parameter and SPREAD OPERATOR
        /*
                // REST PARAMETERS
                function sumar (a,b, ...c) {
                    let resultado = a + b;

                    c.forEach(function(n){
                        resultado += n
                    })
                    return resultado; 
                }

                console.log(sumar(1,2));
                console.log(sumar(1,2,3));
                console.log(sumar(1,2,3,4));
                console.log(sumar(1,2,3,4,5));
                console.log(sumar(1,2,3,4,5,6));
                console.log(sumar(1,2,3,4,5,6,7));

                // SPREAD OPERATOR
                const arr1 = [1,2,3,4,5],
                arr2 = [6,7,8,9,0]

                console.log(arr1, arr2);

                const arr3 = [arr1,arr2];

                console.log(arr3);

                const array3 = [...arr1, ...arr2]

                console.log(array3);
        */
        /*
                //21) ARROW FUNCTION --> new way to define define anonimate function
                //
                // funcion expresada-->cuando  a una variable le asignas el valor de una funcion anonima /when assign the  value of an anonymous function to a variable
                // const greet = function(){
                //     console.log('Hello');
                // }

                // greet(); 

                // Funcion declarada / declared function
                // function greeting(){
                //     console.log('Hi');
                // }

                // const greeting = () => console.log('Hola');
                // greeting();

                const greeting = nombre => console.log(`Hello ${nombre}`);
                greeting('Irma');

                // const increase = function(a,b){
                //     return a + b;
                // }

                const increase = (a,b) => a + b; 
                console.log(increase(10,8));
                // when thw function have some lines, we need the brackts (llaves)
                const functionOfSomeLines = () => {
                    console.log('one');
                    console.log('two');
                    console.log('three');
                }

                functionOfSomeLines();

                const numbers = [1,2,3,4,5];
                
                // numbers.forEach(function(el,index){
                //     console.log(`the element ${el} is in ${index} position`);
                // })
                // when the function hace only one code line, we can omit  brackets
                numbers.forEach((el,index) => console.log(`${el} is in ${index} position`))

                // function Perro() {
                //     console.log(this);
                // }

                // Perro();

                // const perro = {
                //     name : 'Kenai',
                //     bark : function(){
                //         console.log(this); // this es el objeto
                //     }
                // }

                
                const perro = { //--> arrow function tiene la capacidad capturar el contexto del objeto en el que se encuentran. Tener cuidado al usar arrow para declarar metodos dentro de objetos literales.
                    name : 'Kenai',
                    bark : () => {
                        console.log(this); //--> this es el objeto window. Las arrow tiene la capacidad de saltar el contexto en donde estan y reconocer el contexto del objeto padre donde ha sido declarado. En este caso es window (ventana del navegador).Es decir, no es una buena practica declarar o crear un metodo dentro de un objeto a partir de una arrow function (problema del contexto this. )
                    }
                }
                perro.bark();

        */
                // 22) PROTOTIPOS

                // CONSTRUCTION FUNCTION

                // function Animal (name, gender){
                //     //Atributes
                //     this.name = name;
                //     this.gender = gender;
                //     //methods
                //     this.sonar = function(){
                //         console.log('I make sound cause im alive');
                //     }
                //     this.greeting = function(){
                //         console.log(`Hi, my name is ${this.name}`);
                //     }
                // }


                // CONSTRUCTION FUNCTION where asign methods to the prototype, not to the function:
                function Animal (name, gender){
                //Atributes
                this.name = name;
                this.gender = gender;

                }
                //Methods added to the prototype of the construction function (avoiding duplicates):
                Animal.prototype.sonar = function(){
                    console.log('I make sound cause im alive'); 
                }
                Animal.prototype.greeting = function(){
                    console.log(`Hi, my name is ${this.name}`);
                }

                const snoopy = new Animal('Snoopy', 'male')
                const lolaBunny = new Animal('Lola Bunny', 'female');

                snoopy.greeting();
                lolaBunny.greeting();

                let array = [1,2,3,4]
                console.log(array); // _proto_: array

                //METHODS: DIRECTLY ASSIGNES TO THE PROTOTYPE FOR BETTER PERFORMANCE AND DATA OPTIMIZATION, MEMORY. 

                // Do all objects prototype? Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.

                //What is the prototype of an object? The prototype of an object is referred to by the prototype property of the constructor function that creates and initializes the object. The isPrototypeOf() method provides a way to determine if one object is the prototype of another. This technique can be used to determine the class of an object.


                
            




    </script>
</body>
</html>