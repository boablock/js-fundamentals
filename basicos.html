<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Fundamentos JavaScript</h1>
    <P>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Neque ut tempora explicabo ab aliquam ipsam possimus veniam quae in. Error quidem minus quos neque deleniti obcaecati eius consequatur possimus culpa.</P>
    <ul>
        <li> Primavera</li>
        <li> Verano </li>
        <li> Oto√±o </li>
        <li> Invierno </li>
    </ul>
    <script>
        // var hola = 'Hola mundo';
        // let hello = 'Hello world'
        // console.log(hola);
        // console.log(hello);
        // console.log(window);
        // console.log(window.hola);
        // console.log(window.hello);
        // // Ambito de bloque 
        // var musica = 'rock';
        // console.log('Variable musica antes del bloque ', musica);
        // {
        //     let  musica = 'pop';
        //     console.log('Variable musica dentro del bloque', musica );
        // }
        // console.log('Variable musica despues del bloque', musica );
    // CONSTANTES 
    /*
    - No puedes declarar una constante vacia
    - No debe cambiar el valor durante el flujo del programa (simpre que sean valores primitivos, ya que se accede directamente al valor). Con valores compuestos (arrays, objects), se accede a una referencia del valor, se puede usar ya que la referencia no combio, sigue siendo un objeto o un arreglo. 
    */
   /*
        const PI =3.1416
        console.log(PI);

        const objeto = {
            nombre: "jon",
            edad: 35
        }
        const colores = ['amarillo','azul', 'rojo']

        console.log(objeto);
        console.log(colores);

        objeto.correo = 'jonmircha@msn.com'
        colores.push ('aranjado')

        console.log(objeto);
        console.log(colores);
    */
    /* 
        //Cadenas de texto aka Strings
        let nombre='Jon' 
        let apellido = "Mircha"
        let saludo = new String("Hola mundo")
        let lorem = '        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Neque ut tempora explicabo ab aliquam ipsam possimus veniam quae in. Error quidem minus quos neque deleniti obcaecati eius consequatur possimus culpa           '

        console.log(nombre,apellido,saludo);
        console.log(
        nombre.length,
        apellido.length,
        saludo.length,
        nombre.toLowerCase(),
        apellido.toUpperCase(),
        lorem.includes('amet'),
        lorem.includes('jon'),
        lorem, 
        lorem.trim(),
        lorem.split(" "),
        lorem.split(",")
        );
    */
/*
    // Concatenacion
    let nombre = 'jon';
    let apellido = 'Mircha';

    let saludo = 'Hola mi nombre es ' + nombre + ' ' + apellido + '.'
    console.log(saludo);

    // Interpolacion de variables 
    // Templetes Strings¬¥
    let saludo2 = `Hola mi nombre es ${nombre} ${apellido} .`
    console.log(saludo2);

    let ul = ` 
    <ul>
        <li> Primavera</li>
        <li> Verano </li>
        <li> Oto√±o </li>
        <li> Invierno </li>
    </ul>`
    console.log(ul);
    
    // Numbers
    let a = 2;
    let b = new Number (1);
    let c = 7.19;
    let d = '5.6'
    console.log(a,b);
    console.log(c.toFixed(1));
    console.log(c.toFixed(5));
    console.log(parseInt(c));
    console.log(parseFloat(c));
    console.log(typeof c, typeof d);
    console.log(a + b);
    console.log(c + d); // transforma el number en string y no lo suma
    console.log(c + parseInt(d)); // 12.19
    console.log(c + parseFloat(d));
    // TODOS ESTOS METODOS CUELGAN DEL OBJETO Number; son metodos directos del CONSTRUCTOR Number:
    console.log(c + Number.parseFloat(d));
    console.log(c + Number.parseInt(d));
*/
/*
    // Booleans
    let verdadero = true;
    let falso = false; 
    let v = Boolean(true)
    let f = Boolean (false)
    console.log(verdadero, falso, v, f );
    console.log(typeof verdadero, typeof falso)
    // falsy and truthy
    console.log(Boolean(0));
    console.log(Boolean(1));
    console.log(Boolean(""));
    console.log(Boolean(" "));
    console.log(Boolean({}));
    console.log(Boolean([]));
    console.log(Boolean(NaN));
    console.log(Boolean(null));

*/
/*
    // Undefined, null, Nan
    //Undefined: Variable que no fue inicializada.
    let indefinida; 
    let nulo = null; //Asignado intencionalmente por el programador
    console.log(indefinida); //undefined, lo tira js, no se le asifno valor
    console.log(nulo); // es asignado por el programador, es un valor asignado.

    //NaN - Not a Number
    let noEsUnNumero = 'Hola' * 3.5;
    console.log(noEsUnNumero); //NaN 
*/

    // // Funcion declarada
    // function estoEsUnaFuncion(){
    //     console.log('uno');
    //     console.log('dos'); 
    //     console.log('tres');
    // }

    // function unaFuncionQueDevuelveValores(){
    //     console.log('uno');
    //     return '19' //-> corta la ejecucion de la funcion 
    //     console.log('dos'); 
    //     console.log('tres');
    //     return 'La funcion retorna una cadena de texto '
    // }
    // //Invocacion
    // // estoEsUnaFuncion();
    // // let valorDeFuncion = unaFuncionQueDevuelveValores();
    // // console.log(valorDeFuncion);

    // function saludar(nombre = 'desconocido', edad = 6 ){
    //     console.log(`Hola mi nombre es ${nombre} y tengo ${edad} a√±os`);
    // }

    // saludar('Akiba', 7);
    // saludar();
    // // Funciones declaradas VS funciones expresadas 
    // funcionDeclarada(); //--> hoisting, lo imprime igual 
    // function funcionDeclarada(){
    //     console.log('Esto es un funcion declarada y puede invocarse en cualquier parte de nuestro codigo, incluso antes de que la funcion sea declarada');
    // }

    // funcionDeclarada();

    // funcionExpresada();
    // // Funcion anonima 
    // const funcionExpresada = function (){
    //     console.log('Esto es una funcion expresada, es decir, una funcion que se le ha asignado como valor a una variable, si invocamos esta funcion antes de su definicion, JS nos dira..Cannot access funcionExpresada before initialization');
    // }
    // funcionExpresada();
/*
    //Arreglos
    const a = []
    const b = [1, true, 'Hola', ['a', 'b', 'c',[1,2,'üêä']]]
    console.log(a);
    console.log(b);
    console.log(b.length); // 4
    console.log(b[2]); // Hola
    console.log(b[3][3][2]);

    const c = Array.of('x','y','z', 1,2)
    console.log(c);

    const d = Array(100).fill(false);
    console.log(d);

    const e = new Array();
    console.log(e);

    const f = new Array (1,2,3)
    console.log(f);

    const colores = ['Azul', 'Rojo', 'Verde']
    console.log(colores);

    colores.push('Anaranjado')
    console.log(colores);

    colores.pop();
    console.log(colores);
    
    colores.forEach(function(el,index){
        console.log(`<li id='${index}'>${el}</li>`);
    })
*/
    // Objects
    // variables de los objetos --> atributos
    // funciones de los objetos --> metodos
/*
    let a = new String('Hola')
    // console.log(a);

    const b = {}

    console.log(b);

    const c = new Object();
    console.log(c);

    const jon = {
        name: 'juampi',
        surname: 'Boada',
        age: '29',
        pasatiempos:['clases de tenis','programar'],
        contacto: {
            email:'Juampi_boada@gmail.com',
            twitter:'Juampi.boa'
        },
        saludar: function (){
            console.log('Hello =)');
        },
        decirMiNombre: function(){
            console.log(`hola me llamo ${this.name} y tengo ${jon.age}`);
        }
    }

    console.log(jon);
    console.log(jon['name']); // juampi
    console.log(jon.name); // Juampi
    console.log(jon['surname']); // Boada
    console.log(jon.surname); // Boada
    console.log(jon.pasatiempos);
    console.log(jon.pasatiempos[0]);
    console.log(jon.contacto);
    console.log(jon.contacto.twitter);
    console.log(jon.saludar);
    jon.decirMiNombre();

    console.log(Object.keys(jon));
    console.log(Object.values(jon));
    console.log(jon.hasOwnProperty('name')); // true  
    console.log(jon.hasOwnProperty('nombre')); // false
*/
/*
    // 16) BUGS HANDLE STRUCTURE - FINALLY
        try{
            console.log('On try we add code to evaluate it ');
            noExist;
            console.log('Second try mensage');
        }catch(error){
            console.log('Catch capture try codes bugs');
            console.log(error);
        }finally{
            console.log('Finally will be executed at the end of the try-catch block');
        }

        try{
            let numero ='y';
            if(isNaN(numero)){
                throw new Error('The input character is not a number')
            }

            console.log(numero * numero);
        }catch(error){
            console.log(`the following error occurred ${error}`);
        }
    */
        // 17) BREAK AND CONTINUE --> for control structure for, while, do while, switch
    /*
            const numeros = [1,2,3,4,5,6,7,8,9,0];
            
            for (let i = 0; i < numeros.length; i++){
                if(i === 5){
                    break; // break in the fifth iteration
                }
                console.log(numeros[i]);
            }
            for (let i = 0; i < numeros.length; i++){
                if(i === 5){
                    continue; // the sixth iteration is skipped
                }
                console.log(numeros[i]);
            }
    */
            // 18) DESTRUCTURING
    /*
                let numeros = [1,2,3]

                let uno = numeros[0]
                 dos = numeros[1]
                 tres = numeros[2]

                console.log(uno, dos, tres); // 1,2,3

            // WITH DESTRUCTURING
                const [one, two, three] = numeros; // to each of array positions, im keeping in the variables one,two, three
                console.log(one, two, three); // 1,2,3

                const person = {
                    name: 'Pepe',
                    surname: ' Loco',
                    age: 22
                }

                const {name, surname, age} = person

                console.log(name, surname, age); //--> en la destructuracion de los obejtos se deben respetar los nombres de los attributos o variables
                //--> in object destructuring name atributes must be respected

    */
                //19) Literal Objects --> new way to write and asign attributes and methods. Literal objects makes writing procces more easy, facilitates objects writing process. When the value of the atribute and the name are the same. 
    /*
                let name = 'Kenai';
                let  age = 7;

                const dog = {
                    name: name,
                    age: age,
                    ladrar: function(){
                        console.log('GUAU GUAUUU');
                    }
                }

                console.log(dog);
                dog.ladrar();

                const perro = {
                    name,
                    age,
                    breed: 'labrador',
                    ladrar(){
                        console.log('GUAU GUAUUUU GUAUUU');
                    }
                }

                console.log(perro);
                perro.ladrar();

        */
                //20) REST parameter and SPREAD OPERATOR
        /*
                // REST PARAMETERS
                function sumar (a,b, ...c) {
                    let resultado = a + b;

                    c.forEach(function(n){
                        resultado += n
                    })
                    return resultado; 
                }

                console.log(sumar(1,2));
                console.log(sumar(1,2,3));
                console.log(sumar(1,2,3,4));
                console.log(sumar(1,2,3,4,5));
                console.log(sumar(1,2,3,4,5,6));
                console.log(sumar(1,2,3,4,5,6,7));

                // SPREAD OPERATOR
                const arr1 = [1,2,3,4,5],
                arr2 = [6,7,8,9,0]

                console.log(arr1, arr2);

                const arr3 = [arr1,arr2];

                console.log(arr3);

                const array3 = [...arr1, ...arr2]

                console.log(array3);
        */
        /*  
                //21) ARROW FUNCTION --> new way to define define anonimate function
                
                //Funcion expresada -->cuando  a una variable le asignas el valor de una funcion anonima /when assign the  value of an anonymous function to a variable
                const greet = function(){
                    console.log('Hello');
                }

                greet(); 

                //Funcion declarada / declared function
                function greeting(){
                    console.log('Hi');
                }

                const greeting = () => console.log('Hola');
                greeting();

                const greeting = nombre => console.log(`Hello ${nombre}`);
                greeting('Irma');

                // const increase = function(a,b){
                //     return a + b;
                // }

                const increase = (a,b) => a + b; 
                console.log(increase(10,8));
                // when thw function have some lines, we need the brackts (llaves)
                const functionOfSomeLines = () => {
                    console.log('one');
                    console.log('two');
                    console.log('three');
                }

                functionOfSomeLines();

                const numbers = [1,2,3,4,5];
                
                numbers.forEach(function(el,index){
                    console.log(`the element ${el} is in ${index} position`);
                })
                // when the function hace only one code line, we can omit  brackets
                numbers.forEach((el,index) => console.log(`${el} is in ${index} position`))

                // function Perro() {
                //     console.log(this);
                // }

                // Perro();

                // const perro = {
                //     name : 'Kenai',
                //     bark : function(){
                //         console.log(this); // this es el objeto
                //     }
                // }

                
                const perro = { //--> arrow function tiene la capacidad capturar el contexto del objeto en el que se encuentran. Tener cuidado al usar arrow para declarar metodos dentro de objetos literales.
                    name : 'Kenai',
                    bark : () => {
                        console.log(this); //--> this es el objeto window. Las arrow tiene la capacidad de saltar el contexto en donde estan y reconocer el contexto del objeto padre donde ha sido declarado. En este caso es window (ventana del navegador).Es decir, no es una buena practica declarar o crear un metodo dentro de un objeto a partir de una arrow function (problema del contexto this. )
                    }
                }
                perro.bark();

        */
                // 22) PROTOTYPES
        
                // CONSTRUCTION FUNCTION / FUNCION CONSTRUCTORA

                // function Animal (name, gender){
                //     //Atributes
                //     this.name = name;
                //     this.gender = gender;
                //     //methods
                //     this.sonar = function(){
                //         console.log('I make sound cause im alive');
                //     }
                //     this.greeting = function(){
                //         console.log(`Hi, my name is ${this.name}`);
                //     }
                // }


                // CONSTRUCTION FUNCTION / FUNCION CONSTRUCTORA: where asign methods to the prototype, not to the function:
                function Animal (name, gender){
                    //Atributes
                    this.name = name;
                    this.gender = gender;

                }
                //Methods added to the prototype of the construction function (avoiding duplicates):
                Animal.prototype.sonar = function(){
                    console.log('I make sound cause im alive'); 
                }
                Animal.prototype.greeting = function(){
                    console.log(`Hi, my name is ${this.name}`);
                }

               
                //PROTOTIPIC INHERTI / HERENCIA PROTOTIPICA
                    //Dog will be sun of Animal
                    function Dog (name, gender, size){
                        this.super = Animal; // --> im declaring that the parent/ father element of Dog will be Animal.
                        this.super(name, gender);
                        this.size = size; 
                }

                //Perro sera una instancia de animal par ano repetir codigo:
                //DOG IS INHERTING FROM Aniaml.
                Dog.prototype = new Animal();
                Dog.prototype.constructor = Dog; 

                // Sobreescritura de metodos del Prototipo padre en el hijo / Overwiriting of father prototype methods in the sun.

                Dog.prototype.sonar = function(){
                    console.log('Im a dog and my sound is a bark')
                }

                //Creating a new method in class Dog (exclusive of Dog prototype)

                Dog.prototype.ladrar = function(){
                    console.log('Wau, wau');
                }

        
                // const snoopy = new Animal('Snoopy', 'male')
                const snoopy = new Dog('Snoopy', 'male', 'medium')
                const lolaBunny = new Animal('Lola Bunny', 'female');

                console.log(snoopy); // the snoopy prototype is Animal (inherti from animal)
                console.log(lolaBunny); // the lolabunny prototype is Object

                // snoopy.sonar();
                snoopy.greeting();
                snoopy.ladrar();

                // lolaBunny.sonar();
                lolaBunny.greeting();

                let array = [1,2,3,4]
                console.log(array); // _proto_: array
        
                //METHODS: DIRECTLY ASSIGNES TO THE PROTOTYPE FOR BETTER PERFORMANCE AND DATA OPTIMIZATION, MEMORY. 

                // Do all objects prototype? Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.

                //What is the prototype of an object? The prototype of an object is referred to by the prototype property of the constructor function that creates and initializes the object. The isPrototypeOf() method provides a way to determine if one object is the prototype of another. This technique can be used to determine the class of an object. 

                
                //New construction function Avatar (sun of Animal ). Its PROTOTYPE will be Animal. Avatar will inherit the properties of his prototype father (Animal);

                function Avatar (name, gender){
                    this.super = Animal;
                    this.super(name,gender);
                }

                Avatar.prototype =new Animal();
                Avatar.prototype.constructor = Animal;

                Avatar.prototype.greeting = function(){
                    console.log(`Hi, my name is ${this.name}`);
                }

                Avatar.prototype.growl = function(){
                    console.log('Rawrr! Im grunting cause im a Navi Avatar');
                }

                //Navi will inherit  Avatar properties , its own prototype father will vi Avatar.
                function Navi (name, gender, age){
                    this.super = Avatar;
                    this.super(name, gender);
                    this.age = age;
                }

                Navi.prototype = new Avatar();
                Navi.prototype.constructor = Avatar;

                const mike = new Navi ('Mike', 'Female',32)
                const juampi = new Avatar('Juampi', 'Male', 29)
                const fernando = new Animal('Fernando', 'Male', 45)
                const napoleon = new Dog('Napoleon', 'male', 12)

                console.log(mike);
                console.log(juampi);
                console.log(fernando);
                console.log(napoleon);

                mike.growl();
                juampi.greeting();
                fernando.sonar();
                napoleon.ladrar();

        
        
            //CLASSES
            class Animal2 {
                // constructor its a especial method which/that is executed when a class is instantiated 
                constructor(name, gender){
                    this.name = name;
                    this.gender = gender;

                }
                sonar(){
                    console.log('I make sound cause im alive; im ' + this.name); 
                }
                greeting(){
                    console.log(`Hi, my name is ${this.name}`);
                }
                growl(){
                    console.log(`Rawrrrr, im grunting and my name is ${this.name}`);
                }

            }

            const lala = new Animal2('Augusto', 'female');
            const candela = new Animal2('Cadenla', 'female');

            console.log(lala); // the prototype Animal its an object which enherti from the most primitive object in JS that is Object. The methods are/lies in its own prototype directly.
            console.log(candela);

            lala.sonar();
            candela.greeting();

            class Capybara extends Animal2 {
                constructor(name, gender, temper){
                // con el metodo super(), se manda a llamar el constructor de la clase padre
                super(name, gender);
                this.temper = temper; 
                }
                sonar(){
                    console.log('I make sound cause im alive, but i dont bark');
                }
                //overwriting Animal method
                greeting(){
                    console.log(`Hi, im a capybara, my name is ${this.name} and i want to be your ${this.temper} pet`);
                }
                growl(){
                    console.log(`Rawrrrr, im grunting and my name is ${this.name}`);
                }
                static whatAreU(){ //puedo ejecutarlo sin la necesidad de haber creado un objeto( instanciar la clase) del tipo al que pertenece la clase. Es decir, sin instanciar a la clase Cabybara con new Capybara etc.
                    console.log('The dogs are mammifers that belong to the canin family. We are considered humans best friend ');
                }

            }

        
        
            //METODOS ESTATICOS /STATIC METHODS
            Capybara.whatAreU();

            const sol = new Animal2 ('sol', 'female')
            const lolo = new Capybara('Lolo', 'male', 'Friendly')
            
            console.log(sol);
            sol.greeting();
            console.log(lolo);
            lolo.greeting();
            lolo.growl(); //--> this method is inherit from its prototype Animal. Capybara class doenst have growl method.

            
            class Dog2 extends Animal2 {
                constructor(name, gender, temper){
                // con el metodo super(), se manda a llamar el constructor de la clase padre
                super(name, gender);
                this.temper = temper; 
                this.breed = null; 
                }

                sonar(){
                    console.log('I make sound cause im alive, but i dont bark');
                }
                //overwriting Animal method
                greeting(){
                    console.log(`Hi, im a Dog, my name is ${this.name} and i want to be your ${this.temper} pet`);
                }
                growl(){
                    console.log(`Rawrrrr, im grunting and my name is ${this.name}`);
                }
                static whatAreU(){ //puedo ejecutarlo sin la necesidad de haber creado un objeto( instanciar la clase) del tipo al que pertenece la clase. Es decir, sin instanciar a la clase Cabybara con new Capybara etc.
                    console.log('The dogs are mammifers that belong to the canin family. We are considered humans best friend ');
                }
                // METODOS SETTERS AND GETTERS: allows us to establish and obtain class atributes values  / nos permiten establecer y obtener los valores de atributos de atributos de nuestra clase. Son metodos OBTENEDORES /(get) u OBTENEDORES (set) de los valores de atributos de la clase.
                get getBreed(){ // GETTER METHOD / METODOS OBTENEDOR
                    return this.breed;
                }

                set setBreed(breed){ // SETTER METHOD / METODO ESTABLECEDOR
                    this.breed = breed;
                }

            }


            const akiva = new Dog2 ( 'Akiva', 'female', 'friendly')
            const bombon = new Dog2 ('Lala', 'female', 'chill')

            console.log(akiva.getBreed);
            akiva.setBreed = 'Siverian';
            console.log(akiva.getBreed);
            console.log(akiva);
            console.clear();    


            // CONSOLE OBJECT /METHODS
            console.log(console);
            console.error('This is an error')
            console.warn('This is an advise')
            console.info('This is an informative mensage')
            console.log('This is a record of what has happened in our application')

            let name = 'Juampi',
                surname = 'Boada',
                age = '29';

            console.log(name, surname, age);

            console.clear(); // comment alternative
            console.log(window);
            console.log(document); // is the HTML representation throught JavaScript
            console.dir(window);
            console.dir(document);

            console.clear();

            console.group('Jon curses on YouTube'); // ways to representate or print console data. 
            console.log('Javascrip curse');
            console.log('Node.js curse');
            console.log('PWEAs');
            console.log('Flexbox');
            console.log('Dise√±o y programacion web');
            console.groupCollapsed('Jon curses on YouTube');
            console.log('Javascrip curse');
            console.log('Node.js curse');
            console.log('PWEAs');
            console.log('Flexbox');
            console.log('Dise√±o y programacion web');

            console.clear();

            console.log(console);
            console.table(Object.entries(console).sort());
            const numbers = [1,2,3,4,5]
            const vocals = ['a','e','i','o','u']
            console.log(numbers);
            console.table(numbers);
            console.table(vocals);

            console.table(akiva);

            console.clear();

            console.time('How long does my code take?')
            const arreglo = Array(100);

            for (let i = 0; i < arreglo.length; i++){
                array[i] = i
            }

            console.timeEnd('How long does my code take?');
            // console.log(arreglo);

            console.clear();

            for (let i = 0; i <=100; i++){
                console.count('for code'); // to contorl o make a code revise/check.
                console.log(i);
            }

            console.clear();

            //PRUEBAS 

            let x = 3;
            let y = 2;
            let pruebaXY = 'X is always expected to be smaller/less than Y'

            console.assert(x < y, {x,y,pruebaXY}); 

            //LIBRERIAS DE PRUEBAS UNITARIAS --> JAZMIN, MOCA INVESTIGAR 

            console.clear();

            // DATE OBJECT - METHODS / CONSTRUCTOR DATE

            console.log(Date());

            let fecha = new Date();
            console.log(fecha); 

            //day of the month:
            console.log(fecha.getDate());
            //day of the week M T W T F S -> 0 1 2 3 4 5 6
            console.log(fecha.getDay());
            //month of the year J F M A M J J A S O N D -> 0 1 2 3 4 5 6 7 8 9 10 11
            console.log (fecha.getMonth());
            console.log (fecha.getFullYear());
            console.log(fecha.getHours());
            console.log(fecha.getMinutes());
            console.log(fecha.getSeconds());
            console.log(fecha.getMilliseconds());
            console.log(fecha.toString());
            console.log(fecha.toDateString());
            console.log(fecha.toLocaleString());
            console.log(fecha.toLocaleDateString());
            console.log(fecha.toLocaleTimeString());
            console.log(fecha.getTimezoneOffset());
            console.log(fecha.getUTCDate());
            console.log(fecha.getUTCHours());

            //EVERY METHOD HAS ITS OWN UTC - MERIDIAN ZERO (GREENWICH). WHERE IS THE SERVE? IT DOENS MATTER WHERE THE SERVER IS. depends on where the aplicattion is executed, where the aplicattion runs. And it always runs in the browser. Where is the USER? thats the question

            console.log(Date.now()); //--> time stamp 

            //MOMENT JS LIBRARY

            let myBirthday = new Date(1993, 1, 16);

            console.log(myBirthday);



    </script>
</body>
</html>         